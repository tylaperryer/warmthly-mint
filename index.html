<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="theme-color" content="#fff6f1" />
  <meta name="color-scheme" content="light" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Mint - Warmthly</title>
  <!-- Preconnect to essential domains for faster resource loading -->
  <link rel="preconnect" href="https://www.warmthly.org">
  <link rel="preconnect" href="https://post.warmthly.org">
  
  <!-- Favicon Set for All Devices -->
  <link rel="icon" type="image/png" sizes="32x32" href="/candle-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/candle-16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/candle-apple.png">

  <style>
      /* --- ANTI-FLASH AND PERFORMANCE FIXES --- */
      /* 1. Set base background color immediately to prevent white flash */
      :root {
            color-scheme: light;
      }
      html {
            background-color: #fff6f1;
            min-height: 100%;
      }
      /* 2. Hide body content until fonts are loaded to prevent FOUC/FOUT */
      body {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out;
      }
      /* 3. Fade in smoothly once fonts are ready */
      body.fonts-loaded {
            opacity: 1;
            visibility: visible;
      }
      /* --- END ANTI-FLASH FIXES --- */

      /* Inline critical CSS for faster rendering */
      * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
      }
      
      /* --- FONT DEFINITIONS --- */
      @font-face {
            font-family: 'Cormorant Garamond';
            font-style: normal;
            font-weight: 300 700;
            font-display: swap;
            src: url('/fonts/CormorantGaramond-VariableFont_wght.ttf') format('truetype');
      }
      
      @font-face {
            font-family: 'Cormorant Garamond';
            font-style: italic;
            font-weight: 300 700;
            font-display: swap;
            src: url('/fonts/CormorantGaramond-Italic-VariableFont_wght.ttf') format('truetype');
      }
      
      @font-face {
            font-family: 'Inter';
            font-style: normal;
            font-weight: 100 900;
            font-display: swap;
            src: url('/fonts/Inter-VariableFont_opsz,wght.ttf') format('truetype');
      }
      
      @font-face {
            font-family: 'Inter';
            font-style: italic;
            font-weight: 100 900;
            font-display: swap;
            src: url('/fonts/Inter-Italic-VariableFont_opsz,wght.ttf') format('truetype');
      }
      
      html {
            overflow-x: hidden;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
      }
      html::-webkit-scrollbar {
            display: none;
      }
      body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #2c2c2c;
            background: #fff6f1;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
      }
      body::-webkit-scrollbar {
            display: none;
      }
      
      body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: radial-gradient(circle at 20% 30%, rgba(255,140,66,0.15) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(255,182,193,0.12) 0%, transparent 50%),
                        radial-gradient(circle at 40% 70%, rgba(173,216,230,0.1) 0%, transparent 50%),
                        radial-gradient(circle at 90% 80%, rgba(144,238,144,0.08) 0%, transparent 50%),
                        linear-gradient(135deg, #fff6f1 0%, #ffeee6 100%);
            z-index: -1;
            pointer-events: none;
      }
      
      ::selection {
        background: #FF8C42;
        color: #FFFFFF;
      }
      
      .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 120px 20px 40px;
            text-align: center;
            color: #2c2c2c;
            position: relative;
            z-index: 1;
      }
      
      .top-left-heading {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-weight: 700;
            font-size: 2rem;
            color: #FF8C42;
            user-select: none;
            z-index: 1001;
      }

      .top-left-heading .warmthly-link {
            text-decoration: none;
            color: #FF8C42;
      }

      .top-left-heading .mint-text {
            color: #33CE79;
            text-decoration: none;
            transition: color 0.3s ease;
      }
      .top-left-heading .mint-text:hover {
            color: #2ab865;
      }

      .header-right {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            z-index: 1002;
            pointer-events: auto;
      }

      .nav-link {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            color: #FF8C42;
            text-decoration: none;
            font-size: 1rem;
            user-select: none;
            transition: color 0.3s ease;
      }

      .nav-link:hover {
            color: #e07a35;
      }

      .nav-link.nav-link-green {
            color: #33CE79;
      }

      .nav-link.nav-link-green:hover {
            color: #28a75e;
      }

      
      .stoplight-container {
          position: relative;
      }

      .stoplight {
          --tint-color: rgba(255,255,255,0.15);
          --blur-radius: 12px;
          --border-color: rgba(255,255,255,0.25);
          --highlight-color: rgba(255,255,255,0.4);
          --shadow-color: rgba(0,0,0,0.08);
          display: flex;
          flex-direction: column;
          gap: 3px;
          cursor: pointer;
          padding: 8px;
          position: relative;
          background: var(--tint-color);
          backdrop-filter: blur(var(--blur-radius)) saturate(1.2);
          -webkit-backdrop-filter: blur(var(--blur-radius)) saturate(1.2);
          border: 1px solid var(--border-color);
          border-radius: 14px;
          box-shadow: 0 6px 12px var(--shadow-color),
                      inset 0 1px 1px var(--highlight-color),
                      inset 0 -1px 1px rgba(0,0,0,0.05);
          transition: all 0.4s cubic-bezier(0.25,0.8,0.25,1);
          overflow: hidden;
      }

      .stoplight:focus {
          outline: none;
          box-shadow: 0 0 0 3px rgba(255, 140, 66, 0.4);
      }

      .stoplight::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border-radius: inherit;
          background: linear-gradient(135deg, rgba(255,255,255,0.25), rgba(255,255,255,0.1) 50%, rgba(255,255,255,0) 100%);
          pointer-events: none;
          z-index: 1;
          opacity: 0.7;
          transition: opacity 0.4s cubic-bezier(0.25,0.8,0.25,1);
      }

      .stoplight:hover,
      .stoplight.active {
          background: rgba(255,255,255,0.25);
          box-shadow: 0 8px 16px rgba(0,0,0,0.12),
                      inset 0 1px 1px rgba(255,255,255,0.5),
                      inset 0 -1px 1px rgba(0,0,0,0.1);
      }

      .stoplight:hover::before,
      .stoplight.active::before {
          opacity: 1;
      }

      .stoplight-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          position: relative;
          transition: opacity 0.4s cubic-bezier(0.25,0.8,0.25,1);
          z-index: 2;
          opacity: 0.3;
      }

      .stoplight-dot.red { background: #ff4757; }
      .stoplight-dot.yellow { background: #FF8C42; }
      .stoplight-dot.green { background: #33CE79; }

      .stoplight-container:hover .stoplight-dot.red,
      .stoplight.active .stoplight-dot.red { animation: stoplight-cycle-red 10s cubic-bezier(0.25,0.8,0.25,1) infinite; }
      .stoplight-container:hover .stoplight-dot.green,
      .stoplight.active .stoplight-dot.green { animation: stoplight-cycle-green 10s cubic-bezier(0.25,0.8,0.25,1) infinite; }
      .stoplight-container:hover .stoplight-dot.yellow,
      .stoplight.active .stoplight-dot.yellow { animation: stoplight-cycle-yellow 10s cubic-bezier(0.25,0.8,0.25,1) infinite; }

      @keyframes stoplight-cycle-red { 0%, 33.33% { opacity: 1; } 33.34%, 100% { opacity: 0.3; } }
      @keyframes stoplight-cycle-green { 0%, 33.33% { opacity: 0.3; } 33.34%, 66.66% { opacity: 1; } 66.67%, 100% { opacity: 0.3; } }
      @keyframes stoplight-cycle-yellow { 0%, 66.66% { opacity: 0.3; } 66.67%, 100% { opacity: 1; } }

      .dropdown-menu {
          --tint-color: rgba(255,255,255,0.15);
          --blur-radius: 12px;
          --border-color: rgba(255,255,255,0.25);
          --highlight-color: rgba(255,255,255,0.4);
          --shadow-color: rgba(0,0,0,0.08);
          --text-color: #1c2526;
          position: absolute;
          top: 100%;
          right: 0;
          background: var(--tint-color);
          backdrop-filter: blur(var(--blur-radius)) saturate(1.2);
          -webkit-backdrop-filter: blur(var(--blur-radius)) saturate(1.2);
          border-radius: 18px;
          padding: 8px;
          margin-top: 12px;
          min-width: 200px;
          box-shadow: 0 8px 32px var(--shadow-color),
                      inset 0 1px 1px var(--highlight-color),
                      inset 0 -1px 1px rgba(0,0,0,0.05);
          border: 1px solid var(--border-color);
          opacity: 0;
          visibility: hidden;
          transform: translateY(-12px) scale(0.94);
          transition: all 0.4s cubic-bezier(0.4,0,0.2,1);
          overflow: hidden;
      }

      .dropdown-menu::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border-radius: inherit;
          background: linear-gradient(135deg, rgba(255,255,255,0.25), rgba(255,255,255,0.1) 50%, rgba(255,255,255,0) 100%);
          pointer-events: none;
          z-index: 1;
          opacity: 0.7;
      }

      .dropdown-menu.active {
          opacity: 1;
          visibility: visible;
          transform: translateY(0) scale(1);
      }

      .dropdown-item {
          display: block;
          padding: 12px 16px;
          margin: 2px 0;
          color: var(--text-color);
          text-decoration: none;
          font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
          font-weight: 500;
          font-size: 0.95rem;
          transition: all 0.3s cubic-bezier(0.25,0.8,0.25,1);
          border-radius: 10px;
          position: relative;
          z-index: 2;
      }

      .dropdown-item:hover { color: #FF8C42; }
      .dropdown-item:first-child { margin-top: 0; }
      .dropdown-item:last-child { margin-bottom: 0; }
      
      .page-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.8rem;
            color: #FF8C42;
            margin-bottom: 1rem;
            font-weight: 600;
            text-align: center;
            letter-spacing: 0.02em;
      }
      
      .main-text {
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            margin-bottom: 3rem;
            opacity: 0.85;
            color: #2c2c2c;
            line-height: 1.7;
      }
      
      .database-section {
            margin: 3rem 0;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s cubic-bezier(0.4,0,0.2,1), transform 0.6s cubic-bezier(0.4,0,0.2,1);
      }

      .database-section.visible {
            opacity: 1;
            transform: translateY(0);
      }

      .database-header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 12px;
      }

      .embed-live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #33CE79;
            /* --- MODIFICATION START: Add transform to fix choppy text rendering --- */
            transform: translateZ(0);
            /* --- MODIFICATION END --- */
      }

      .embed-live-indicator .live-dot {
            width: 8px;
            height: 8px;
            background: #33CE79;
            border-radius: 50%;
            animation: pulse 0.8s infinite cubic-bezier(0.5,0,0.5,1);
      }
      
      @keyframes pulse {
            0%, 80%, 100% { opacity: 1; }
            40% { opacity: 0.2; }
      }

      /* Statistics Dashboard */
      .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.2);
      }


      .stat-item {
            text-align: center;
      }

      .stat-value {
            font-family: 'Inter', sans-serif;
            font-size: 1.8rem;
            font-weight: 600;
            color: #FF8C42;
            margin-bottom: 0.25rem;
      }

      .stat-label {
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            color: #2c2c2c;
            opacity: 0.7;
      }

      /* Donation Pool Container */
      .donation-pool-container {
            position: relative;
            width: 100%;
            height: 600px;
            background: linear-gradient(135deg, rgba(255,140,66,0.08), rgba(255,140,66,0.03));
            border-radius: 20px;
            border: 1px solid rgba(255,140,66,0.15);
            box-shadow: 0 8px 20px rgba(255,140,66,0.1);
            overflow: visible; /* Changed to visible so panel can be outside */
            cursor: default;
      }

      .donation-pool-container.focus-mode .pool-search {
            display: none;
      }

      /* Search Bar */
      .pool-search {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 12px;
            padding: 0.5rem 1rem;
            min-width: 200px;
            display: flex;
            align-items: center;
      }

      .pool-search input {
            background: transparent;
            border: none;
            outline: none;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            color: #2c2c2c;
            flex: 1;
            min-width: 0;
      }

      .pool-search input::placeholder {
            color: #2c2c2c;
            opacity: 0.5;
      }

      .pool-search:focus-within {
            border-color: #FF8C42;
            box-shadow: 0 0 0 2px rgba(255,140,66,0.2);
      }

      /* Legend Toggle Button */
      .pool-legend-toggle {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.25);
            color: #FF8C42;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      }

      .pool-legend-toggle:hover {
            background: rgba(255,255,255,0.25);
            transform: scale(1.1);
      }

      .pool-legend-toggle:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 140, 66, 0.4);
      }

      /* Legend Dropdown */
      .pool-legend-dropdown {
            position: absolute;
            top: 50px;
            left: 0;
            z-index: 101;
            min-width: 180px;
            max-width: 220px;
      }

      .legend-title {
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            color: #FF8C42;
            margin-bottom: 0.5rem;
            padding: 0 8px;
      }

      .legend-items {
            list-style: none;
            padding: 0;
            margin: 0;
      }

      .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 6px 10px;
            margin: 1px 0;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            color: var(--text-color);
            border-radius: 6px;
            transition: background 0.2s ease;
      }

      .legend-item:hover {
            background: rgba(255,255,255,0.1);
      }

      .legend-item span:first-child {
            font-size: 1.2rem;
            line-height: 1;
            min-width: 24px;
            text-align: center;
      }

      /* Focus Mode Styles */
      .donation-pool-container.focus-mode {
            position: relative;
      }

      .donation-pool-container.focus-mode .pool-search {
            display: none;
      }

      .exit-focus-mode {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 102;
            background: rgba(255,140,66,0.2);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255,140,66,0.3);
            border-radius: 12px;
            padding: 0.8rem 1.5rem;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: #FF8C42;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            display: none;
      }

      .donation-pool-container.focus-mode .exit-focus-mode {
            display: block;
      }

      .exit-focus-mode:hover,
      .exit-focus-mode:focus {
            background: rgba(255,140,66,0.3);
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 8px 25px rgba(255,140,66,0.2);
            outline: 2px solid #FF8C42;
            outline-offset: 2px;
      }

      /* Detailed Information Panel - Only visible in focus mode, positioned on right side OUTSIDE the physics box */
      .donation-details-panel {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%) translateX(20px);
            z-index: 103;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 18px;
            padding: 1rem;
            max-width: 280px;
            width: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
            border: 1px solid rgba(255,255,255,0.25);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4,0,0.2,1);
            max-height: 70vh;
            overflow-y: auto;
            /* Ensure it's outside the container by using fixed positioning relative to viewport */
            margin-left: 0;
      }

      .donation-details-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(-50%) translateX(0);
      }

      /* Ensure donation pool itself still clips coins properly */
      .donation-pool-container .donation-pool {
            overflow: hidden;
      }

      .details-header {
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: #FF8C42;
            margin-bottom: 0.75rem;
      }

      .details-section {
            margin-bottom: 0.75rem;
      }

      .details-label {
            font-family: 'Inter', sans-serif;
            font-size: 0.75rem;
            font-weight: 600;
            color: #2c2c2c;
            opacity: 0.7;
            margin-bottom: 0.2rem;
      }

      .details-value {
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            color: #2c2c2c;
            margin-bottom: 0.5rem;
            word-wrap: break-word;
      }

      .details-breakdown {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255,255,255,0.2);
      }

      .breakdown-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            color: #2c2c2c;
            cursor: pointer;
            border-radius: 6px;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            transition: background 0.2s ease;
      }

      .breakdown-item:hover {
            background: rgba(255,255,255,0.1);
      }

      .breakdown-item.highlighted {
            background: rgba(255,140,66,0.2);
      }

      .cent.highlighted {
            outline: 3px solid #FF8C42;
            outline-offset: 2px;
            z-index: 200 !important;
      }

      /* Scrooge McDuck Duck */
      .scrooge-duck {
            position: absolute;
            cursor: pointer;
            z-index: 150;
            transition: transform 0.2s ease;
            user-select: none;
            pointer-events: auto;
      }

      .scrooge-duck:hover {
            transform: translate(-50%, -50%) scale(1.2);
      }

      .scrooge-popup {
            position: absolute;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 0.5rem 0.75rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.75rem;
            font-weight: 600;
            color: #FF8C42;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            z-index: 151;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px) scale(0.9);
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
            white-space: nowrap;
      }

      .scrooge-popup.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
      }

      .cent.search-match {
            opacity: 1 !important;
            filter: none !important;
      }

      .cent.search-no-match {
            opacity: 0.2 !important;
            filter: grayscale(100%) !important;
            transition: opacity 0.3s ease, filter 0.3s ease;
      }

      .donation-pool {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
      }

      /* Cent Element */
      .cent {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 10;
            display: flex;
            user-select: none;
            pointer-events: auto;
            transform: translate(-50%, -50%);
            will-change: transform;
            touch-action: manipulation; /* Improve touch responsiveness */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
      }

      .cent:hover {
            transform: translate(-50%, -50%) scale(1.3);
            z-index: 100;
      }

      .cent.emoji {
            background: transparent;
            box-shadow: none;
            font-size: 18px;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1;
      }

      /* Donation Tag */
      .donation-tag {
            position: absolute;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 1rem;
            min-width: 200px;
            max-width: 300px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: opacity 0.3s ease, transform 0.3s ease;
            font-family: 'Inter', sans-serif;
      }

      .donation-tag.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
      }

      .tag-header {
            font-weight: 600;
            color: #FF8C42;
            margin-bottom: 0.5rem;
            font-size: 1rem;
      }

      .tag-item {
            font-size: 0.85rem;
            color: #2c2c2c;
            margin: 0.25rem 0;
            opacity: 0.8;
      }

      .tag-item strong {
            opacity: 1;
            color: #2c2c2c;
      }

      /* "See Every Cent" button in tooltip */
      .view-cents-button {
            width: 100%;
            margin-top: 0.75rem;
            padding: 0.6rem 1rem;
            background: rgba(255,140,66,0.2);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255,140,66,0.3);
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            color: #FF8C42;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      }

      .view-cents-button:hover {
            background: rgba(255,140,66,0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255,140,66,0.2);
      }

      .view-cents-button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 140, 66, 0.4);
      }

      .view-cents-button:active {
            transform: scale(0.98);
      }

      
      .page-title, .main-text { cursor: text; }
      
      .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.94);
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 18px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
            border: 1px solid rgba(255,255,255,0.25);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4,0,0.2,1);
            z-index: 1003;
      }
      
      .modal.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
      }
      
      .modal-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.4rem;
            color: #FF8C42;
            margin-bottom: 1rem;
            font-weight: 600;
      }
      
      .modal-text {
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            color: #2c2c2c;
            line-height: 1.6;
            margin-bottom: 1.5rem;
      }

      .modal-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
      }

      .modal-textarea {
            width: 100%;
            min-height: 150px;
            padding: 1rem;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            color: #2c2c2c;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            resize: vertical;
            outline: none;
            transition: border-color 0.3s ease;
      }

      .modal-textarea:focus {
            border-color: #FF8C42;
            box-shadow: 0 0 0 2px rgba(255,140,66,0.2);
      }

      .modal-textarea::placeholder {
            color: #2c2c2c;
            opacity: 0.5;
      }

      .modal-submit {
            background: rgba(255,140,66,0.2);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255,140,66,0.3);
            border-radius: 12px;
            padding: 0.8rem 1.5rem;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: #FF8C42;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      }

      .modal-submit:hover {
            background: rgba(255,140,66,0.3);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255,140,66,0.2);
      }

      .modal-submit:active {
            transform: scale(0.98);
      }
      
      .modal-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #FF8C42;
            cursor: pointer;
            position: absolute;
            top: 1rem;
            right: 1rem;
      }
      
      .modal-close:focus, .modal-submit:focus {
          outline: 2px solid #FF8C42;
          outline-offset: 2px;
      }
      
      /* Accessibility: Respect reduced motion preference */
      @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                  animation-duration: 0.01ms !important;
                  animation-iteration-count: 1 !important;
                  transition-duration: 0.01ms !important;
            }
      }

      /* Loading and error states */
      .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,140,66,0.3);
            border-top-color: #FF8C42;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
            to { transform: rotate(360deg); }
      }

      .error-message {
            background: rgba(255,71,87,0.1);
            border: 1px solid rgba(255,71,87,0.3);
            border-radius: 12px;
            padding: 1rem;
            margin: 1rem 0;
            color: #ff4757;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
      }

      .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #2c2c2c;
            opacity: 0.6;
            font-family: 'Inter', sans-serif;
      }

      /* Skip navigation link for accessibility - visually hidden until focused */
      .skip-link {
            border: 0;
            clip: rect(0 0 0 0);
            height: 1px;
            margin: -1px;
            overflow: hidden;
            padding: 0;
            position: absolute;
            width: 1px;
      }

      .skip-link:focus {
            clip: auto;
            height: auto;
            margin: 0;
            overflow: visible;
            position: absolute;
            top: 10px;
            left: 10px;
            width: auto;
            z-index: 10000;
            background: #FF8C42;
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 4px;
      }

      @media (max-width: 768px) {
            .container {
                  padding-top: 80px;
                  padding-left: 15px;
                  padding-right: 15px;
            }
            .top-left-heading {
                  font-size: 1.6rem;
                  top: 15px;
                  left: 15px;
            }
            .header-right {
                  top: 15px;
                  right: 15px;
                  gap: 15px;
            }
            .nav-link {
                  font-size: 0.9rem;
            }
            .page-title { font-size: 1.5rem; }
            .main-text { font-size: 1rem; }
            .dropdown-menu { min-width: 180px; }
            .donation-pool-container { height: 500px; }
            .stats-dashboard { grid-template-columns: 1fr; gap: 0.75rem; padding: 1rem; }
            .stat-value { font-size: 1.5rem; }
            .pool-search { min-width: 150px; top: 10px; right: 10px; padding: 0.4rem 0.8rem; }
            .pool-search input { font-size: 0.85rem; }
            .pool-legend-toggle { width: 28px; height: 28px; font-size: 1rem; }
            .donation-details-panel { 
                  max-width: calc(100vw - 40px); 
                  right: 10px;
                  padding: 0.75rem;
                  max-height: 80vh;
            }
            .exit-focus-mode { padding: 0.6rem 1rem; font-size: 0.9rem; }
      }
      
      .preload-fonts {
            font-family: 'Cormorant Garamond';
            font-family: 'Inter';
            visibility: hidden;
            position: absolute;
      }
  </style>
  
  <link rel="dns-prefetch" href="//warmthly.org">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body class="fonts-loading">
  <a href="#main-content" class="skip-link">Skip to main content</a>
  <div class="preload-fonts">.</div>
  
  <header class="top-left-heading">
    <a href="https://www.warmthly.org" class="warmthly-link">Warmthly</a>
    <a href="https://mint.warmthly.org" class="mint-text">Mint</a>
  </header>
  
  <nav class="header-right" role="navigation" aria-label="Main navigation">
    <a href="https://mint.warmthly.org/research" class="nav-link nav-link-green" aria-label="View our research and methods">Research</a>
    <div class="stoplight-container">
      <div class="stoplight" id="stoplight">
        <div class="stoplight-dot red"></div>
        <div class="stoplight-dot yellow"></div>
        <div class="stoplight-dot green"></div>
      </div>
      
      <!-- --- MODIFICATION START: Removed 'Family' and 'Projects' links --- -->
      <div class="dropdown-menu" id="dropdown-menu">
        <a href="https://www.warmthly.org" class="dropdown-item">Home</a>
        <a href="https://post.warmthly.org" class="dropdown-item">Post</a>
      </div>
      <!-- --- MODIFICATION END --- -->
    </div>
  </nav>

  <main class="container" id="main-content" role="main">
    <h1 class="page-title">Mint</h1>
    <p class="main-text">
      <b>We track your every cent and our every decision right before you.</b> It is our commitment to you that we will forever track and provide utmost transparency for our every action and your every donation. Given the nature of our organization, you are able to fork and copy-paste our processes for your refining, those are also available on this page.
    </p>
    
    <div class="database-section">
      <div class="database-header">
        <div class="embed-live-indicator">
          <div class="live-dot"></div>
          <span>Live</span>
        </div>
      </div>
      <div class="stats-dashboard">
        <div class="stat-item">
          <div class="stat-value" id="totalDonations">0</div>
          <div class="stat-label">Total Donations</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="totalAmount">$0.00</div>
          <div class="stat-label">Amount Raised</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="totalDonors">0</div>
          <div class="stat-label">Donors</div>
        </div>
      </div>
      <div class="donation-pool-container" id="donationPool">
        <button class="pool-legend-toggle" id="poolLegendToggle" aria-label="Show donation legend" title="Show donation legend">?</button>
        <div class="pool-legend-dropdown dropdown-menu" id="poolLegendDropdown" role="dialog" aria-label="Donation legend">
          <h3 class="legend-title">Donation Key</h3>
          <ul class="legend-items" id="legendItems">
            <!-- Items will be generated by JavaScript -->
          </ul>
        </div>
        <div class="pool-search">
          <input type="text" id="donorSearch" placeholder="Search donor..." autocomplete="off" aria-label="Search donations by donor name">
        </div>
        <button class="exit-focus-mode" id="exitFocusMode" aria-label="Back to all donations">‚Üê Back to All Donations</button>
        <div class="donation-pool" id="donationPoolArea" role="region" aria-label="Donation pool visualization"></div>
        <div class="empty-state" id="emptyState" style="display: none;">No donations yet. Check back soon!</div>
      </div>
      <div class="donation-details-panel" id="donationDetailsPanel" role="dialog" aria-label="Donation details">
        <div class="details-header" id="detailsHeader">Donation Details</div>
        <div class="details-section">
          <div class="details-label">Donor</div>
          <div class="details-value" id="detailsDonor">-</div>
        </div>
        <div class="details-section">
          <div class="details-label">Total Donation</div>
          <div class="details-value" id="detailsAmount">-</div>
        </div>
        <div class="details-section">
          <div class="details-label">Date</div>
          <div class="details-value" id="detailsDate">-</div>
        </div>
        <div class="details-section">
          <div class="details-label">Purpose</div>
          <div class="details-value" id="detailsPurpose">-</div>
        </div>
        <div class="details-section">
          <div class="details-label">Category</div>
          <div class="details-value" id="detailsCategory">-</div>
        </div>
        <div class="details-section">
          <div class="details-label">Transaction ID</div>
          <div class="details-value" id="detailsTransactionId">-</div>
        </div>
        <div class="details-breakdown" id="detailsBreakdown" style="display: none;">
          <div class="details-label">Fund Allocation</div>
          <div id="breakdownItems"></div>
        </div>
      </div>
    </div>
  </main>
  
  <script>
      // Airtable Configuration
      // Airtable configuration - API key is now handled securely on the backend
      // To set up:
      // 1. Add AIRTABLE_API_KEY to your Vercel environment variables
      // 2. Update tableName to match your Airtable table name
      // 3. Update fieldMappings to match your column names exactly
      const airtableConfig = {
            baseId: "appDmVaty9tcrUKsn", // From your embed URL
            tableName: "Donations", // Update this to match your Airtable table name
            viewId: "shrI3VVTE2iCyz3rO", // From your embed URL (optional, helps with filtering)
            // Field mappings - update these to match your Airtable column names EXACTLY
            fieldMappings: {
                  amount: "Amount", // Column name for donation amount (must be a number field)
                  donor: "Donor", // Column name for donor name
                  date: "Date", // Column name for date (date field)
                  purpose: "Purpose", // Column name for purpose
                  category: "Category", // Column name for category
                  transactionId: "Transaction ID" // Column name for transaction ID
            },
            pollInterval: 10000, // Poll for updates every 10 seconds (in milliseconds)
            requestTimeout: 10000 // Request timeout in milliseconds
      };

      // Constants for configuration
      const CONFIG = {
            MAX_VISIBLE_CENTS: 1000, // Reduced from 5000 for better performance
            PROCESSED_DONATIONS_CACHE_SIZE: 10000, // LRU cache size limit
            SEARCH_DEBOUNCE_MS: 300, // Debounce search input
            WALL_THICKNESS: 50,
            COIN_SIZE: 20,
            COIN_OFFSET_X: 25, // Tag positioning offset
            COIN_OFFSET_Y: 10,
            BATCH_SIZE: 50,
            HISTORICAL_DELAY: 0,
            NEW_DONATION_DELAY: 50
      };

      // Donation tier system for emoji-based clustering
      const DONATION_TIERS = [
            { threshold: 500, emoji: 'üí∞', size: 40, label: 'Large Donation' },
            { threshold: 100, emojis: ['üí¥', 'üíµ', 'üí∂', 'üí∑'], size: 35, label: 'Medium Donation' },
            { threshold: 25, emoji: 'üëõ', size: 30, label: 'Small Donation' },
            { threshold: 1, emoji: 'ü™ô', size: 20, label: 'Coin' }
      ];

      // Simple input sanitization function (XSS prevention)
      function sanitizeInput(str) {
            if (typeof str !== 'string') return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
      }

      // Simple LRU cache implementation
      class LRUCache {
            constructor(maxSize) {
                  this.maxSize = maxSize;
                  this.cache = new Map();
            }

            has(key) {
                  return this.cache.has(key);
            }

            add(key) {
                  // If at capacity, remove oldest (first) entry
                  if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
                        const firstKey = this.cache.keys().next().value;
                        this.cache.delete(firstKey);
                  }
                  // Remove and re-add to make it most recently used
                  if (this.cache.has(key)) {
                        this.cache.delete(key);
                  }
                  this.cache.set(key, true);
            }
      }

      // Donation Pool Animation System
      class DonationPool {
            constructor(container) {
                  this.container = container;
                  this.pool = document.getElementById('donationPoolArea');
                  this.cents = [];
                  this.activeTags = new WeakMap(); // Use WeakMap to prevent memory leaks
                  this.processedDonations = new LRUCache(CONFIG.PROCESSED_DONATIONS_CACHE_SIZE);
                  this.centPool = []; // Object pool for coin elements
                  this.maxVisibleCents = CONFIG.MAX_VISIBLE_CENTS;
                  this.clusterThreshold = 100; // Cluster coins when too many
                  this.visibleCents = new Set();
                  this.coinPositions = []; // Track coin positions for physics
                  this.coinSize = CONFIG.COIN_SIZE;
                  this.searchQuery = '';
                  this.searchDebounceTimer = null;
                  this.isProcessingDonations = false; // Lock to prevent race conditions
                  this.pendingDOMUpdates = []; // Batch DOM updates
                  this.rafScheduled = false;
                  this.cashEmojiIndex = 0; // Counter for cycling through cash emojis
                  
                  // Matter.js variables
                  this.engine = null;
                  this.world = null;
                  this.runner = null;
                  this.render = null;
                  this.poolBody = null; // Reference to the main pool container body
                  this.stats = {
                        totalDonations: 0,
                        totalAmount: 0,
                        totalDonors: 0,
                        donors: new Set()
                  };
                  this.isDragging = false; // Track if user is currently dragging a coin
                  this.draggedBody = null; // Track the body currently being dragged
                  
                  // Error and loading state elements
                  this.errorContainer = null;
                  this.loadingIndicator = null;
                  
                  // Focus mode state
                  this.isFocusMode = false;
                  this.focusedDonation = null;
                  this.hiddenObjects = []; // Store objects hidden during focus mode
                  this.focusedCents = []; // Store cents created in focus mode
                  this.centCreationTimeouts = []; // Store timeout IDs to cancel cent creation
                  this.scroogeDuck = null; // Reference to Scrooge McDuck duck element
                  this.scroogePopup = null; // Reference to Scrooge popup
                  this.activeMobileTag = null; // Track which cent's tag is active on mobile
                  this.physicsUpdateSkip = 0; // Counter for skipping physics updates when there are many coins
                  
                  this.init();
            }

            init() {
                  this.containerRect = this.container.getBoundingClientRect();
                  this.updateContainerSize();
                  window.addEventListener('resize', () => this.updateContainerSize());
                  
                  // Create error container
                  this.createErrorContainer();
                  
                  // Setup search with debouncing
                  const searchInput = document.getElementById('donorSearch');
                  if (searchInput) {
                        searchInput.addEventListener('input', (e) => {
                              // Debounce search input
                              if (this.searchDebounceTimer) {
                                    clearTimeout(this.searchDebounceTimer);
                              }
                              this.searchDebounceTimer = setTimeout(() => {
                                    this.searchQuery = e.target.value.toLowerCase().trim();
                                    this.updateSearchFilter();
                              }, CONFIG.SEARCH_DEBOUNCE_MS);
                        });
                  }
                  
                  // Setup legend
                  this.setupLegend();
                  
                  // Setup focus mode exit button
                  const exitFocusBtn = document.getElementById('exitFocusMode');
                  if (exitFocusBtn) {
                        exitFocusBtn.addEventListener('click', () => this.exitFocusMode());
                  }
                  
                  // Setup click-outside handler for mobile tooltips
                  this.setupMobileTooltipDismiss();
                  
                  // Check if Airtable is configured
                  // Setup Airtable listener (API key is now handled on backend)
                  this.setupAirtableListener().catch(err => {
                        this.showError('Failed to load donations. Please refresh the page.');
                        console.error('Airtable setup error:', err);
                        // Fallback to mock data on error
                        this.loadMockData();
                  });
                  
                  this.setupPhysics();
            }

            setupMobileTooltipDismiss() {
                  // On mobile, close tooltips when tapping outside
                  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                  if (isTouchDevice) {
                        document.addEventListener('click', (e) => {
                              // Don't close if clicking on a cent or its tag
                              const clickedCent = e.target.closest('.cent');
                              const clickedTag = e.target.closest('.donation-tag');
                              
                              if (!clickedCent && !clickedTag && this.activeMobileTag) {
                                    this.hideTag(this.activeMobileTag);
                                    this.activeMobileTag = null;
                              }
                        }, true); // Use capture phase to catch events early
                  }
            }

            setupLegend() {
                  const legendItemsEl = document.getElementById('legendItems');
                  const legendToggle = document.getElementById('poolLegendToggle');
                  const legendDropdown = document.getElementById('poolLegendDropdown');
                  
                  if (!legendItemsEl || !legendToggle || !legendDropdown) return;
                  
                  // Populate legend from DONATION_TIERS
                  DONATION_TIERS.forEach((tier, index) => {
                        const nextTier = DONATION_TIERS[index - 1];
                        let rangeText;
                        
                        if (tier.threshold === 1) {
                              rangeText = `$1 - $${nextTier ? (nextTier.threshold - 0.01).toFixed(2) : '‚àû'}`;
                        } else if (nextTier) {
                              rangeText = `$${tier.threshold} - $${(nextTier.threshold - 0.01).toFixed(2)}`;
                        } else {
                              rangeText = `$${tier.threshold}+`;
                        }
                        
                        const emoji = tier.emoji || (tier.emojis ? tier.emojis[0] : 'ü™ô');
                        const li = document.createElement('li');
                        li.className = 'legend-item';
                        li.innerHTML = `<span>${emoji}</span> <span>${rangeText}</span>`;
                        legendItemsEl.appendChild(li);
                  });
                  
                  // Toggle legend dropdown
                  let isLegendOpen = false;
                  legendToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        isLegendOpen = !isLegendOpen;
                        legendDropdown.classList.toggle('active', isLegendOpen);
                  });
                  
                  // Close legend when clicking outside
                  document.addEventListener('click', (e) => {
                        if (!legendToggle.contains(e.target) && !legendDropdown.contains(e.target) && isLegendOpen) {
                              isLegendOpen = false;
                              legendDropdown.classList.remove('active');
                        }
                  });
                  
                  document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && isLegendOpen) {
                              isLegendOpen = false;
                              legendDropdown.classList.remove('active');
                        }
                  });
            }

            createErrorContainer() {
                  this.errorContainer = document.createElement('div');
                  this.errorContainer.className = 'error-message';
                  this.errorContainer.style.display = 'none';
                  this.errorContainer.setAttribute('role', 'alert');
                  this.errorContainer.setAttribute('aria-live', 'polite');
                  const databaseSection = this.container.querySelector('.database-section');
                  if (databaseSection) {
                        databaseSection.insertBefore(this.errorContainer, databaseSection.firstChild);
                  }
            }

            showError(message) {
                  if (this.errorContainer) {
                        this.errorContainer.textContent = message;
                        this.errorContainer.style.display = 'block';
                  }
            }

            hideError() {
                  if (this.errorContainer) {
                        this.errorContainer.style.display = 'none';
                  }
            }

            setupPhysics() {
                  const { Engine, Render, World, Bodies, Runner, Mouse, MouseConstraint, Events } = Matter;

                  // 1. Create engine and world
                  this.engine = Engine.create();
                  this.world = this.engine.world;
                  this.world.gravity.y = 1; // Standard gravity

                  // --- Performance Optimizations ---
                  // Enable sleeping for better performance (coins at rest won't be simulated)
                  this.engine.enableSleeping = true;
                  
                  // Note: Grid broadphase removed - using default broadphase for better compatibility
                  // Grid broadphase can be re-enabled later if needed with proper configuration
                  
                  // Set higher iterations for smoother physics
                  this.engine.positionIterations = 10; // Higher iterations = smoother, more accurate physics
                  this.engine.velocityIterations = 8;
                  
                  // Physics speed adjustment - slightly faster for more responsive feel
                  this.engine.timing.timeScale = 1.0; // Use normal speed for smoother animation
                  // --- END Performance Optimizations ---

                  // 2. Add a mouse controller for dragging coins
                  const mouse = Mouse.create(this.pool);
                  const mouseConstraint = MouseConstraint.create(this.engine, {
                        mouse: mouse,
                        constraint: {
                              stiffness: 0.8, // How rigid the "grab" is (higher = firmer grip)
                              render: {
                                    visible: false // Don't draw the grab line
                              }
                        }
                  });

                  World.add(this.world, mouseConstraint);

                  // Listen for mouse events on the constraint
                  Events.on(mouseConstraint, 'startdrag', (event) => {
                        // Track dragging state
                        this.isDragging = true; // A drag has started!
                        
                        // Store and wake up the coin being dragged
                        this.draggedBody = event.body;
                        if (this.draggedBody && Matter.Sleeping) {
                              Matter.Sleeping.set(this.draggedBody, false);
                        }
                        
                        // Mark all cents as not potential taps when dragging starts
                        this.cents.forEach(cent => {
                              if (cent._potentialTap) {
                                    cent._potentialTap = false;
                              }
                        });
                  });

                  Events.on(mouseConstraint, 'enddrag', (event) => {
                        // Track dragging state
                        this.isDragging = false; // The drag has ended!
                        this.draggedBody = null; // Clear the dragged body reference
                  });
                  
                  // Listen for collisions to wake up coins that collide with the dragged coin
                  // Use collisionStart only (not collisionActive) to avoid performance issues
                  // Throttle the wake-up calls to prevent lag
                  let lastWakeUpTime = 0;
                  const WAKE_UP_THROTTLE = 50; // Only wake up coins every 50ms max
                  
                  Events.on(this.engine, 'collisionStart', (event) => {
                        if (!this.isDragging || !this.draggedBody) return;
                        
                        const now = Date.now();
                        if (now - lastWakeUpTime < WAKE_UP_THROTTLE) return;
                        lastWakeUpTime = now;
                        
                        const pairs = event.pairs;
                        for (let i = 0; i < pairs.length; i++) {
                              const pair = pairs[i];
                              const bodyA = pair.bodyA;
                              const bodyB = pair.bodyB;
                              
                              // Check if either body is the dragged body
                              if (bodyA === this.draggedBody) {
                                    // Wake up the coin that collided with the dragged coin
                                    if (Matter.Sleeping && Matter.Sleeping.get(bodyB)) {
                                          Matter.Sleeping.set(bodyB, false);
                                    }
                              } else if (bodyB === this.draggedBody) {
                                    // Wake up the coin that collided with the dragged coin
                                    if (Matter.Sleeping && Matter.Sleeping.get(bodyA)) {
                                          Matter.Sleeping.set(bodyA, false);
                                    }
                              }
                        }
                  });

                  // Store mouse constraint for potential cleanup
                  this.mouseConstraint = mouseConstraint;

                  // 3. Create boundaries (walls and floor)
                  const poolWidth = this.poolWidth;
                  const poolHeight = this.poolHeight;
                  const wallThickness = CONFIG.WALL_THICKNESS;

                  // Create a container body for the pool area
                  this.poolBody = Bodies.rectangle(poolWidth / 2, poolHeight / 2, poolWidth, poolHeight, { 
                        isStatic: true, 
                        isSensor: true,
                        render: { visible: false }
                  });
                  
                  // Create static boundaries (bottom, left, right)
                  const ground = Bodies.rectangle(poolWidth / 2, poolHeight + wallThickness / 2, poolWidth, wallThickness, { isStatic: true, friction: 1, restitution: 0.1 });
                  const leftWall = Bodies.rectangle(-wallThickness / 2, poolHeight / 2, wallThickness, poolHeight * 2, { isStatic: true, friction: 1 });
                  const rightWall = Bodies.rectangle(poolWidth + wallThickness / 2, poolHeight / 2, wallThickness, poolHeight * 2, { isStatic: true, friction: 1 });

                  World.add(this.world, [ground, leftWall, rightWall]);

                  // 4. Run the engine
                  this.runner = Runner.run(this.engine);
                  
                  // 5. Setup animation loop to sync DOM elements with physics bodies
                  // Use requestAnimationFrame directly for smoother 60fps updates
                  const updateDOM = () => {
                        // Update all coins
                        this.cents.forEach(cent => {
                              if (cent.body) {
                                    const x = cent.body.position.x;
                                    const y = cent.body.position.y;
                                    const angle = cent.body.angle;
                                    
                                    cent.style.left = x + 'px';
                                    cent.style.top = y + 'px';
                                    cent.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
                              }
                        });
                        
                        // Also update Scrooge duck if it exists
                        if (this.scroogeDuck && this.scroogeDuck.body) {
                              const x = this.scroogeDuck.body.position.x;
                              const y = this.scroogeDuck.body.position.y;
                              const angle = this.scroogeDuck.body.angle;
                              
                              this.scroogeDuck.style.left = x + 'px';
                              this.scroogeDuck.style.top = y + 'px';
                              this.scroogeDuck.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
                        }
                        
                        requestAnimationFrame(updateDOM);
                  };
                  
                  // Start the animation loop
                  requestAnimationFrame(updateDOM);
            }

            updateSearchFilter() {
                  // Create a list of matching donations for click-to-focus
                  const matchingDonations = [];
                  
                  this.cents.forEach(cent => {
                        if (!cent.donationData) return;
                        
                        const donorName = (cent.donationData.donor || '').toLowerCase();
                        const matches = !this.searchQuery || donorName.includes(this.searchQuery);
                        
                        if (matches) {
                              cent.classList.remove('search-no-match');
                              cent.classList.add('search-match');
                              
                              // Collect unique matching donations
                              const donationId = cent.dataset.donationId;
                              if (donationId && !matchingDonations.find(d => d.id === donationId)) {
                                    matchingDonations.push({
                                          id: donationId,
                                          donation: cent.donationData
                                    });
                              }
                        } else {
                              cent.classList.remove('search-match');
                              cent.classList.add('search-no-match');
                        }
                  });
                  
                  // Store matching donations for potential click-to-focus feature
                  this.matchingDonations = matchingDonations;
            }

            updateContainerSize() {
                  this.containerRect = this.container.getBoundingClientRect();
                  this.poolWidth = this.containerRect.width;
                  this.poolHeight = this.containerRect.height;
                  
                  // Update physics world boundaries if initialized
                  if (this.world) {
                        const { World, Bodies } = Matter;
                        const wallThickness = 50;
                        
                        // Remove old boundaries (assuming they were the only static bodies added)
                        // A more robust solution would track the boundary bodies and remove them specifically.
                        // For simplicity, we'll re-add the boundaries in setupPhysics on a full re-init if needed, 
                        // but for a simple resize, we'll just rely on the CSS container size.
                        // For a full physics update, the entire world would need to be reset, but that's complex.
                        // For now, we'll rely on the initial boundaries being large enough.
                        // A better fix is to ensure the pool area has a fixed size or the boundaries are updated.
                        
                        // For this instruction set, we will assume the initial boundaries are sufficient 
                        // or that the user will handle the full physics world update on resize if necessary.
                  }
            }

            async setupAirtableListener() {
                  try {
                        // Load initial donations
                        await this.fetchAirtableDonations(true);
                        
                        // Set up polling for updates with error handling
                        this.airtablePollInterval = setInterval(() => {
                              this.fetchAirtableDonations(false).catch(err => {
                                    console.error('Polling error:', err);
                                    // Don't show error for every polling failure, only log
                              });
                        }, airtableConfig.pollInterval);
                  } catch (error) {
                        this.showError('Failed to connect to donation database. Please check your connection and refresh.');
                        throw error;
                  }
            }

            async fetchAirtableDonations(isInitialLoad = false) {
                  // Prevent concurrent fetches (race condition fix)
                  if (this.isProcessingDonations) {
                        return;
                  }
                  
                  this.isProcessingDonations = true;
                  
                  try {
                        // Build URL for backend proxy endpoint
                        let url = `/api/airtable?baseId=${encodeURIComponent(airtableConfig.baseId)}&tableName=${encodeURIComponent(airtableConfig.tableName)}`;
                        if (airtableConfig.viewId) {
                              url += `&viewId=${encodeURIComponent(airtableConfig.viewId)}`;
                        }
                        
                        // Add timeout using AbortController
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), airtableConfig.requestTimeout);
                        
                        const response = await fetch(url, {
                              method: 'GET',
                              headers: {
                                    'Content-Type': 'application/json'
                              },
                              signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);

                        if (!response.ok) {
                              const errorData = await response.json().catch(() => ({}));
                              const errorMsg = errorData.error?.message || `Airtable API error: ${response.status} ${response.statusText}`;
                              console.warn(errorMsg);
                              if (isInitialLoad) {
                                    if (response.status === 500 && errorData.error?.code === 'NOT_CONFIGURED') {
                                          this.showError('Airtable not configured on server. Using mock data for demonstration.');
                                    } else {
                                          this.showError(errorMsg + ' Using mock data for demonstration.');
                                    }
                                    this.loadMockData();
                              }
                              this.isProcessingDonations = false;
                              return;
                        }

                        const data = await response.json();
                        const records = data.records || [];
                        
                        if (isInitialLoad) {
                              console.log(`Loaded ${records.length} donations from Airtable`);
                        }

                        let newDonations = 0;
                        records.forEach(record => {
                              const donationId = record.id;
                              
                              // Use LRU cache with atomic check-and-add
                              if (!this.processedDonations.has(donationId)) {
                                    this.processedDonations.add(donationId);
                                    newDonations++;
                                    
                                    // Map Airtable fields to donation structure
                                    const fields = record.fields || {};
                                    const donation = {
                                          amount: this.parseAmount(fields[airtableConfig.fieldMappings.amount]),
                                          donor: fields[airtableConfig.fieldMappings.donor] || 'Anonymous',
                                          date: this.parseDate(fields[airtableConfig.fieldMappings.date]),
                                          purpose: fields[airtableConfig.fieldMappings.purpose] || 'N/A',
                                          category: fields[airtableConfig.fieldMappings.category] || 'General',
                                          transactionId: fields[airtableConfig.fieldMappings.transactionId] || record.id
                                    };
                                    
                                    // Validate donation data before adding
                                    if (this.validateDonation(donation)) {
                                          this.addDonation(donation, donationId, isInitialLoad);
                                    }
                              }
                        });
                        
                        if (!isInitialLoad && newDonations > 0) {
                              console.log(`Added ${newDonations} new donation(s) from Airtable`);
                        }
                        
                        this.hideError();
                  } catch (error) {
                        console.error('Error fetching Airtable data:', error);
                        
                        let errorMessage = 'Error loading donations. ';
                        if (error.name === 'AbortError') {
                              errorMessage += 'Request timed out.';
                        } else if (error.message.includes('CORS')) {
                              errorMessage += 'CORS error: Make sure your Airtable base allows API access. You may need to use a backend proxy.';
                        } else {
                              errorMessage += error.message || 'Unknown error occurred.';
                        }
                        
                        if (isInitialLoad) {
                              this.showError(errorMessage);
                              console.warn('Falling back to mock data.');
                              this.loadMockData();
                        } else {
                              // For polling errors, just log (don't spam user)
                              console.warn('Polling error:', errorMessage);
                        }
                  } finally {
                        this.isProcessingDonations = false;
                  }
            }

            validateDonation(donation) {
                  // Validate amount (must be positive number)
                  const amount = parseFloat(donation.amount);
                  if (isNaN(amount) || amount <= 0 || !isFinite(amount)) {
                        console.warn('Invalid donation amount:', donation.amount);
                        return false;
                  }
                  
                  // Validate date
                  if (donation.date) {
                        const date = new Date(donation.date);
                        if (isNaN(date.getTime())) {
                              console.warn('Invalid donation date:', donation.date);
                              return false;
                        }
                  }
                  
                  return true;
            }

            parseAmount(amount) {
                  if (typeof amount === 'number') {
                        // Validate number
                        if (isNaN(amount) || !isFinite(amount) || amount < 0) {
                              return 0;
                        }
                        return amount;
                  }
                  if (typeof amount === 'string') {
                        // Remove currency symbols and parse
                        const cleaned = amount.replace(/[^0-9.]/g, '');
                        const parsed = parseFloat(cleaned);
                        // Validate parsed result
                        if (isNaN(parsed) || !isFinite(parsed) || parsed < 0) {
                              return 0;
                        }
                        return parsed;
                  }
                  return 0;
            }

            parseDate(dateValue) {
                  if (!dateValue) return new Date().toISOString();
                  if (dateValue instanceof Date) return dateValue.toISOString();
                  if (typeof dateValue === 'string') {
                        const date = new Date(dateValue);
                        return isNaN(date.getTime()) ? new Date().toISOString() : date.toISOString();
                  }
                  return new Date().toISOString();
            }

            loadMockData() {
                  // Mock data for demonstration - showcasing different donation tiers
                  const mockDonations = [
                        // Small coin donations
                        { amount: 1.00, donor: 'Alice', date: new Date().toISOString(), purpose: 'General Support', category: 'General', transactionId: 'TXN-001' },
                        { amount: 4.50, donor: 'Bob', date: new Date(Date.now() - 3600000).toISOString(), purpose: 'General Support', category: 'General', transactionId: 'TXN-002' },
                        // Small donation (purse tier)
                        { amount: 30.00, donor: 'Charlie', date: new Date(Date.now() - 7200000).toISOString(), purpose: 'General Support', category: 'General', transactionId: 'TXN-003' },
                        // Medium donation (cash tier)
                        { amount: 150.00, donor: 'Diana', date: new Date(Date.now() - 10800000).toISOString(), purpose: 'Project Funding', category: 'Projects', transactionId: 'TXN-004' },
                        { amount: 250.00, donor: 'Edward', date: new Date(Date.now() - 14400000).toISOString(), purpose: 'Project Funding', category: 'Projects', transactionId: 'TXN-005' },
                        // Large donation (money bag tier)
                        { amount: 750.00, donor: 'MegaCorp Inc.', date: new Date(Date.now() - 18000000).toISOString(), purpose: 'Major Sponsor', category: 'Projects', transactionId: 'TXN-006' }
                  ];

                  mockDonations.forEach((donation, index) => {
                        setTimeout(() => {
                              this.addDonation(donation, `mock-${index}`, true);
                        }, index * 800);
                  });
            }

            addDonation(donation, donationId, isHistorical = false) {
                  // Validate donation before processing
                  if (!this.validateDonation(donation)) {
                        return;
                  }
                  
                  const amount = parseFloat(donation.amount) || 0;
                  
                  // Update stats
                  this.stats.totalDonations++;
                  this.stats.totalAmount += amount;
                  if (donation.donor && donation.donor !== 'Anonymous') {
                        this.stats.donors.add(donation.donor);
                        this.stats.totalDonors = this.stats.donors.size;
                  }
                  
                  this.updateStats();
                  
                  // Find the correct tier for this donation amount
                  const tier = DONATION_TIERS.find(t => amount >= t.threshold);
                  if (!tier) {
                        console.warn('Donation amount too small:', amount);
                        return;
                  }
                  
                  // Determine which emoji to use
                  let emoji;
                  if (tier.emojis) {
                        // If it's the cash tier, cycle through the emojis
                        emoji = tier.emojis[this.cashEmojiIndex % tier.emojis.length];
                        this.cashEmojiIndex++;
                  } else {
                        emoji = tier.emoji;
                  }
                  
                  // Create ONE physics object for this entire donation
                  this.createDonationObject(donation, donationId, emoji, tier.size, tier.label, isHistorical);
            }

            recalculateStats() {
                  // Recalculate stats from actual rendered cents to prevent desync
                  const actualDonations = new Set();
                  let actualAmount = 0;
                  const actualDonors = new Set();
                  
                  this.cents.forEach(cent => {
                        if (cent.donationData) {
                              const id = cent.dataset.donationId;
                              if (id && !actualDonations.has(id)) {
                                    actualDonations.add(id);
                                    actualAmount += parseFloat(cent.donationData.amount) || 0;
                                    if (cent.donationData.donor && cent.donationData.donor !== 'Anonymous') {
                                          actualDonors.add(cent.donationData.donor);
                                    }
                              }
                        }
                  });
                  
                  // Update stats if there's a discrepancy
                  if (Math.abs(this.stats.totalAmount - actualAmount) > 0.01) {
                        this.stats.totalDonations = actualDonations.size;
                        this.stats.totalAmount = actualAmount;
                        this.stats.totalDonors = actualDonors.size;
                        this.updateStats();
                  }
            }

            enterFocusMode(donation, donationId) {
                  if (this.isFocusMode) return;
                  
                  this.isFocusMode = true;
                  this.focusedDonation = { ...donation, donationId };
                  
                  // Clear active mobile tag
                  this.activeMobileTag = null;
                  
                  // Hide all existing tooltips when entering focus mode
                  this.cents.forEach(cent => {
                        this.hideTag(cent);
                  });
                  
                  // Immediately desaturate all other donation objects (don't hide them)
                  // This must happen BEFORE creating cents to prevent them from appearing
                  this.cents.forEach(cent => {
                        if (cent.dataset.donationId !== donationId) {
                              // Add desaturation class (like search-no-match) immediately
                              cent.classList.add('search-no-match');
                        } else {
                              // Hide the focused donation emoji (we'll show individual cents instead)
                              if (cent.body) {
                                    Matter.World.remove(this.world, cent.body);
                              }
                              cent.style.display = 'none';
                              this.hiddenObjects.push(cent);
                        }
                  });
                  
                  // Clear the focused cents array
                  this.focusedCents = [];
                  
                  // Generate individual cents for this donation
                  const amount = parseFloat(donation.amount) || 0;
                  const coinsCount = Math.floor(amount);
                  
                  // Clear any existing timeouts
                  this.centCreationTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
                  this.centCreationTimeouts = [];
                  
                  // Create cents at a steady flow of 10 per second (100ms per cent)
                  const centDelay = 100; // 100ms = 10 cents per second
                  for (let i = 0; i < coinsCount; i++) {
                        const isLastCent = (i === coinsCount - 1);
                        const timeoutId = setTimeout(() => {
                              if (this.isFocusMode) { // Only create if still in focus mode
                                    this.createFocusCent(donation, donationId, i, coinsCount);
                                    
                                    // If this is the last cent and donation is over $100, show Scrooge McDuck
                                    if (isLastCent && amount > 100) {
                                          // Wait a bit for the last cent to settle, then show duck
                                          setTimeout(() => {
                                                if (this.isFocusMode) {
                                                      this.createScroogeDuck();
                                                }
                                          }, 500);
                                    }
                              }
                        }, i * centDelay);
                        this.centCreationTimeouts.push(timeoutId);
                  }
                  
                  // Show UI elements
                  this.container.classList.add('focus-mode');
                  this.showDonationDetails(donation);
                  
                  // Clear search
                  const searchInput = document.getElementById('donorSearch');
                  if (searchInput) {
                        searchInput.value = '';
                        this.searchQuery = '';
                  }
            }

            createFocusCent(donation, donationId, index, total) {
                  const { Bodies, World } = Matter;
                  
                  const cent = document.createElement('div');
                  cent.className = 'cent emoji';
                  cent.textContent = 'ü™ô';
                  cent.style.fontSize = `${CONFIG.COIN_SIZE}px`;
                  cent.dataset.donationId = donationId;
                  cent.dataset.centIndex = index;
                  
                  // Store donation data
                  cent.donationData = {
                        donor: donation.donor || 'Anonymous',
                        amount: donation.amount,
                        date: donation.date,
                        purpose: donation.purpose || 'N/A',
                        category: donation.category || 'General',
                        transactionId: donation.transactionId || 'N/A',
                        centIndex: index,
                        totalCents: total
                  };
                  
                  // Physics body
                  const radius = CONFIG.COIN_SIZE / 2;
                  const startX = this.poolWidth / 2 + (Math.random() - 0.5) * 20;
                  const startY = -radius;
                  
                  const coinBody = Bodies.circle(startX, startY, radius, {
                        restitution: 0.2,
                        friction: 0.8,
                        density: 0.001,
                        label: 'cent'
                  });
                  
                  cent.body = coinBody;
                  World.add(this.world, coinBody);
                  
                  // DOM styling - hide until positioned correctly to prevent glitch
                  cent.style.position = 'absolute';
                  cent.style.width = CONFIG.COIN_SIZE + 'px';
                  cent.style.height = CONFIG.COIN_SIZE + 'px';
                  cent.style.left = startX + 'px';
                  cent.style.top = startY + 'px';
                  cent.style.display = 'flex';
                  cent.style.visibility = 'hidden'; // Hide until positioned
                  cent.style.opacity = '1';
                  cent.style.lineHeight = CONFIG.COIN_SIZE + 'px';
                  cent.style.textAlign = 'center';
                  cent.style.justifyContent = 'center';
                  cent.style.alignItems = 'center';
                  cent.style.willChange = 'transform';
                  
                  // Make visible in next frame once positioned
                  requestAnimationFrame(() => {
                        cent.style.visibility = 'visible';
                  });
                  
                  // Accessibility
                  const donorName = sanitizeInput(donation.donor || 'Anonymous');
                  cent.setAttribute('role', 'img');
                  cent.setAttribute('aria-label', `Cent ${index + 1} of ${total} from ${donorName}`);
                  
                  // Event listeners (for focus mode cents)
                  cent._mouseenterHandler = (e) => this.showTag(e, cent);
                  cent._mouseleaveHandler = () => this.scheduleHideTag(cent);
                  cent._touchStartHandler = (e) => this.handleCentTouchStart(e, cent);
                  cent._touchEndHandler = (e) => this.handleCentTouchEnd(e, cent);
                  
                  cent.addEventListener('mouseenter', cent._mouseenterHandler);
                  cent.addEventListener('mouseleave', cent._mouseleaveHandler);
                  // Use capture phase to catch touch events before Matter.js
                  cent.addEventListener('touchstart', cent._touchStartHandler, { passive: false, capture: true });
                  cent.addEventListener('touchend', cent._touchEndHandler, { passive: false, capture: true });
                  cent.style.cursor = 'pointer';
                  cent.style.touchAction = 'manipulation'; // Improve touch responsiveness
                  cent.hasListeners = true;
                  
                  this.pool.appendChild(cent);
                  this.cents.push(cent);
                  this.focusedCents.push(cent);
            }

            exitFocusMode() {
                  if (!this.isFocusMode) return;
                  
                  this.isFocusMode = false;
                  
                  // Stop all pending cent creation
                  this.centCreationTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
                  this.centCreationTimeouts = [];
                  
                  // Clear focused cents
                  this.focusedCents.forEach(cent => {
                        if (cent.body) {
                              Matter.World.remove(this.world, cent.body);
                        }
                        if (cent.parentNode) {
                              cent.parentNode.removeChild(cent);
                        }
                        // Remove from main cents array
                        const index = this.cents.indexOf(cent);
                        if (index > -1) {
                              this.cents.splice(index, 1);
                        }
                  });
                  this.focusedCents = [];
                  
                  // Remove desaturation from all donations
                  this.cents.forEach(cent => {
                        cent.classList.remove('search-no-match');
                  });
                  
                  // Restore hidden objects (the focused donation emoji)
                  this.hiddenObjects.forEach(cent => {
                        cent.style.display = '';
                        if (cent.body) {
                              Matter.World.add(this.world, cent.body);
                        }
                  });
                  
                  this.hiddenObjects = [];
                  this.focusedDonation = null;
                  
                  // Remove Scrooge McDuck if present
                  if (this.scroogeDuck) {
                        // Remove physics body
                        if (this.scroogeDuck.body) {
                              Matter.World.remove(this.world, this.scroogeDuck.body);
                        }
                        
                        // Remove event listeners
                        if (this.scroogeDuck._hidePopupHandler) {
                              document.removeEventListener('click', this.scroogeDuck._hidePopupHandler);
                        }
                        if (this.scroogeDuck._clickHandler) {
                              this.scroogeDuck.removeEventListener('click', this.scroogeDuck._clickHandler);
                        }
                        if (this.scroogeDuck._popupTimeout) {
                              clearTimeout(this.scroogeDuck._popupTimeout);
                        }
                        
                        if (this.scroogeDuck.parentNode) {
                              this.scroogeDuck.parentNode.removeChild(this.scroogeDuck);
                        }
                        this.scroogeDuck = null;
                  }
                  this.scroogePopup = null;
                  
                  // Hide UI elements
                  this.container.classList.remove('focus-mode');
                  this.hideDonationDetails();
            }

            createScroogeDuck() {
                  if (this.scroogeDuck) return; // Already exists
                  
                  const { Bodies, World } = Matter;
                  
                  const duck = document.createElement('div');
                  duck.className = 'scrooge-duck';
                  duck.textContent = 'ü¶Ü';
                  duck.setAttribute('role', 'button');
                  duck.setAttribute('aria-label', 'Scrooge McDuck');
                  
                  // Physics body for duck - same size as coins
                  const duckSize = CONFIG.COIN_SIZE; // Same size as coins
                  const radius = duckSize / 2;
                  const startX = this.poolWidth / 2 + (Math.random() - 0.5) * 20;
                  const startY = -radius; // Start above the pool
                  
                  const duckBody = Bodies.circle(startX, startY, radius, {
                        restitution: 0.2, // Same as coins
                        friction: 0.8,    // Same as coins
                        density: 0.001,   // Same as coins
                        label: 'duck'
                  });
                  
                  duck.body = duckBody;
                  World.add(this.world, duckBody);
                  
                  // DOM styling - hide until positioned correctly
                  duck.style.position = 'absolute';
                  duck.style.width = duckSize + 'px';
                  duck.style.height = duckSize + 'px';
                  duck.style.left = startX + 'px';
                  duck.style.top = startY + 'px';
                  duck.style.fontSize = duckSize + 'px';
                  duck.style.display = 'flex';
                  duck.style.visibility = 'hidden'; // Hide until positioned
                  duck.style.opacity = '1';
                  duck.style.lineHeight = duckSize + 'px';
                  duck.style.textAlign = 'center';
                  duck.style.justifyContent = 'center';
                  duck.style.alignItems = 'center';
                  duck.style.willChange = 'transform';
                  duck.style.transform = 'translate(-50%, -50%)';
                  
                  // Make visible in next frame once positioned
                  requestAnimationFrame(() => {
                        duck.style.visibility = 'visible';
                  });
                  
                  // Duck position will be updated in the main physics loop (already set up in setupPhysics)
                  
                  // Create popup
                  const popup = document.createElement('div');
                  popup.className = 'scrooge-popup';
                  popup.textContent = 'Scrooge McDuck';
                  popup.style.position = 'absolute';
                  popup.style.left = '50%';
                  popup.style.top = '100%';
                  popup.style.transform = 'translateX(-50%)';
                  popup.style.marginTop = '10px';
                  
                  // Click handler to show popup
                  let popupTimeout = null;
                  const clickHandler = (e) => {
                        e.stopPropagation();
                        
                        // Clear any existing timeout
                        if (popupTimeout) {
                              clearTimeout(popupTimeout);
                        }
                        
                        popup.classList.toggle('visible');
                        
                        // Hide popup after 3 seconds if visible
                        if (popup.classList.contains('visible')) {
                              popupTimeout = setTimeout(() => {
                                    popup.classList.remove('visible');
                                    popupTimeout = null;
                              }, 3000);
                        } else {
                              popupTimeout = null;
                        }
                  };
                  
                  duck.addEventListener('click', clickHandler);
                  
                  // Hide popup when clicking outside
                  const hidePopupHandler = (e) => {
                        if (!duck.contains(e.target) && !popup.contains(e.target)) {
                              popup.classList.remove('visible');
                              if (popupTimeout) {
                                    clearTimeout(popupTimeout);
                                    popupTimeout = null;
                              }
                        }
                  };
                  document.addEventListener('click', hidePopupHandler);
                  
                  // Store handlers for cleanup
                  duck._clickHandler = clickHandler;
                  duck._hidePopupHandler = hidePopupHandler;
                  duck._popupTimeout = popupTimeout;
                  
                  duck.appendChild(popup);
                  this.pool.appendChild(duck);
                  
                  this.scroogeDuck = duck;
                  this.scroogePopup = popup;
            }

            showDonationDetails(donation) {
                  const panel = document.getElementById('donationDetailsPanel');
                  if (!panel) return;
                  
                  // Format date
                  let formattedDate = 'N/A';
                  if (donation.date) {
                        try {
                              const date = new Date(donation.date);
                              if (!isNaN(date.getTime())) {
                                    formattedDate = new Intl.DateTimeFormat(navigator.language || 'en-US', {
                                          year: 'numeric',
                                          month: 'short',
                                          day: 'numeric',
                                          hour: '2-digit',
                                          minute: '2-digit'
                                    }).format(date);
                              }
                        } catch (e) {
                              console.warn('Date formatting error:', e);
                        }
                  }
                  
                  // Populate details
                  document.getElementById('detailsDonor').textContent = sanitizeInput(donation.donor || 'Anonymous');
                  document.getElementById('detailsAmount').textContent = `$${parseFloat(donation.amount).toFixed(2)}`;
                  document.getElementById('detailsDate').textContent = formattedDate;
                  document.getElementById('detailsPurpose').textContent = sanitizeInput(donation.purpose || 'N/A');
                  document.getElementById('detailsCategory').textContent = sanitizeInput(donation.category || 'General');
                  document.getElementById('detailsTransactionId').textContent = sanitizeInput(donation.transactionId || 'N/A');
                  
                  // Show breakdown if available (for future enhancement with allocation data)
                  const breakdown = document.getElementById('detailsBreakdown');
                  if (breakdown && donation.breakdown) {
                        // Future: Show fund allocation breakdown
                        breakdown.style.display = 'block';
                  } else {
                        breakdown.style.display = 'none';
                  }
                  
                  // Show panel
                  panel.classList.add('active');
            }

            hideDonationDetails() {
                  const panel = document.getElementById('donationDetailsPanel');
                  if (panel) {
                        panel.classList.remove('active');
                  }
            }

            createDonationObject(donation, donationId, emoji, size, label, isHistorical = false) {
                  const { Bodies, World } = Matter;
                  
                  // Create the DOM element
                  const element = document.createElement('div');
                  element.className = 'cent emoji';
                  element.textContent = emoji;
                  element.style.fontSize = `${size}px`;
                  element.dataset.donationId = donationId;
                  
                  // Store donation data
                  element.donationData = {
                        donor: donation.donor || 'Anonymous',
                        amount: donation.amount,
                        date: donation.date,
                        purpose: donation.purpose || 'N/A',
                        category: donation.category || 'General',
                        transactionId: donation.transactionId || 'N/A'
                  };
                  
                  // --- Physics Body ---
                  // Create a circular body, adjusting the radius based on the emoji size
                  const radius = size / 2;
                  const startX = this.poolWidth / 2 + (Math.random() - 0.5) * 20;
                  const startY = -radius; // Start above the screen
                  
                  const body = Bodies.circle(startX, startY, radius, {
                        restitution: 0.3, // Bounciness
                        friction: 0.7,    // How it slides against others
                        density: 0.001 * size, // Make bigger objects heavier
                        label: label
                  });
                  
                  // Attach the body to the element and add to the world
                  element.body = body;
                  World.add(this.world, body);
                  
                  // Initial DOM positioning - hide until positioned correctly to prevent glitch
                  element.style.position = 'absolute';
                  element.style.width = size + 'px';
                  element.style.height = size + 'px';
                  element.style.left = startX + 'px';
                  element.style.top = startY + 'px';
                  element.style.display = 'flex';
                  element.style.visibility = 'hidden'; // Hide until positioned
                  element.style.opacity = '1';
                  element.style.lineHeight = size + 'px';
                  element.style.textAlign = 'center';
                  element.style.justifyContent = 'center';
                  element.style.alignItems = 'center';
                  element.style.willChange = 'transform'; // Performance optimization
                  
                  // Make visible in next frame once positioned
                  requestAnimationFrame(() => {
                        element.style.visibility = 'visible';
                  });
                  
                  // --- Accessibility ---
                  // Note: Removed tabindex and keyboard handlers - coins are not keyboard navigable
                  // Users can still interact via mouse/touch and search
                  const donorName = sanitizeInput(donation.donor || 'Anonymous');
                  const amountText = `$${parseFloat(donation.amount).toFixed(2)}`;
                  element.setAttribute('role', 'img');
                  element.setAttribute('aria-label', `${label} from ${donorName}, ${amountText}.`);
                  
                  // Add event listeners for tooltips (hover for desktop, click/touch for mobile)
                  element._mouseenterHandler = (e) => this.showTag(e, element);
                  element._mouseleaveHandler = () => this.scheduleHideTag(element);
                  element._touchStartHandler = (e) => this.handleCentTouchStart(e, element);
                  element._touchEndHandler = (e) => this.handleCentTouchEnd(e, element);
                  
                  element.addEventListener('mouseenter', element._mouseenterHandler);
                  element.addEventListener('mouseleave', element._mouseleaveHandler);
                  // Use capture phase to catch touch events before Matter.js
                  element.addEventListener('touchstart', element._touchStartHandler, { passive: false, capture: true });
                  element.addEventListener('touchend', element._touchEndHandler, { passive: false, capture: true });
                  element.style.cursor = 'pointer'; // Change to pointer to indicate clickability
                  element.style.touchAction = 'manipulation'; // Improve touch responsiveness
                  element.hasListeners = true;
                  
                  // Add the element to the DOM and the main 'cents' array
                  this.pool.appendChild(element);
                  this.cents.push(element);
                  this.visibleCents.add(element);
                  
                  // If in focus mode, desaturate this element if it's not the focused donation
                  if (this.isFocusMode && this.focusedDonation && donationId !== this.focusedDonation.donationId) {
                        element.classList.add('search-no-match');
                  }
                  
                  // Hide empty state if we have coins
                  const emptyState = document.getElementById('emptyState');
                  if (emptyState) {
                        emptyState.style.display = 'none';
                  }
                  
                  // Update search filter if search is active
                  if (this.searchQuery) {
                        this.updateSearchFilter();
                  }
            }

            getCentFromPool() {
                  // Reuse cent element from pool if available
                  if (this.centPool.length > 0) {
                        const cent = this.centPool.pop();
                        // Ensure it's removed from any previous parent
                        if (cent.parentNode) {
                              cent.parentNode.removeChild(cent);
                        }
                        return cent;
                  }
                  
                  // Create new cent element
                  const cent = document.createElement('div');
                  cent.className = 'cent emoji';
                  cent.textContent = 'ü™ô';
                  return cent;
            }

            returnCentToPool(cent) {
                  // Clean up and return to pool
                  cent.style.left = '';
                  cent.style.top = '';
                  cent.style.transform = '';
                  
                  // Remove event listeners properly
                  if (cent._mouseenterHandler) {
                        cent.removeEventListener('mouseenter', cent._mouseenterHandler);
                        cent._mouseenterHandler = null;
                  }
                  if (cent._mouseleaveHandler) {
                        cent.removeEventListener('mouseleave', cent._mouseleaveHandler);
                        cent._mouseleaveHandler = null;
                  }
                  if (cent._touchStartHandler) {
                        cent.removeEventListener('touchstart', cent._touchStartHandler, { capture: true });
                        cent._touchStartHandler = null;
                  }
                  if (cent._touchEndHandler) {
                        cent.removeEventListener('touchend', cent._touchEndHandler, { capture: true });
                        cent._touchEndHandler = null;
                  }
                  // Clear touch tracking data
                  cent._touchStartTime = null;
                  cent._touchStartX = null;
                  cent._touchStartY = null;
                  cent._potentialTap = null;
                  cent._touchTarget = null;
                  // Note: No keyboard handlers to remove - coins are not keyboard navigable
                  
                  // Clear active mobile tag if this is it
                  if (this.activeMobileTag === cent) {
                        this.activeMobileTag = null;
                  }
                  
                  // Remove from active tags
                  if (this.activeTags.has(cent)) {
                        const tag = this.activeTags.get(cent);
                        if (tag && tag.parentNode) {
                              tag.parentNode.removeChild(tag);
                        }
                        this.activeTags.delete(cent);
                  }
                  
                  cent.donationData = null;
                  cent.hasListeners = false;
                  
                  // Remove physics body from world
                  if (cent.body) {
                        Matter.World.remove(this.world, cent.body);
                        cent.body = null;
                  }
                  
                  this.centPool.push(cent);
            }



            showTag(event, cent) {
                  if (this.isDragging) return; // If dragging, do not show tooltip!
                  
                  // Don't show tooltips in focus mode - only sidebar should show info
                  if (this.isFocusMode) return;
                  
                  // Cancel any pending hide timeout for this cent
                  if (cent._hideTagTimeout) {
                        clearTimeout(cent._hideTagTimeout);
                        cent._hideTagTimeout = null;
                  }
                  
                  // If tag already exists, just make sure it's visible
                  if (this.activeTags.has(cent)) {
                        const existingTag = this.activeTags.get(cent);
                        existingTag.classList.add('visible');
                        return;
                  }
                  
                  const tag = document.createElement('div');
                  tag.className = 'donation-tag';
                  tag.setAttribute('role', 'tooltip');
                  tag.setAttribute('aria-live', 'polite');
                  
                  const data = cent.donationData;
                  if (!data) return;
                  
                  // Validate and format date
                  let formattedDate = 'N/A';
                  if (data.date) {
                        try {
                              const date = new Date(data.date);
                              if (!isNaN(date.getTime())) {
                                    formattedDate = new Intl.DateTimeFormat(navigator.language || 'en-US', {
                                          year: 'numeric',
                                          month: 'short',
                                          day: 'numeric',
                                          hour: '2-digit',
                                          minute: '2-digit'
                                    }).format(date);
                              }
                        } catch (e) {
                              console.warn('Date formatting error:', e);
                        }
                  }
                  
                  // Sanitize all user-provided data to prevent XSS
                  const donor = sanitizeInput(data.donor || 'Anonymous');
                  const amount = parseFloat(data.amount) || 0;
                  const purpose = sanitizeInput(data.purpose || 'N/A');
                  const category = sanitizeInput(data.category || 'General');
                  const transactionId = sanitizeInput(data.transactionId || 'N/A');
                  
                  const donationId = cent.dataset.donationId;
                  
                  let tagContent = `
                        <div class="tag-header">${donor}</div>
                        <div class="tag-item"><strong>Amount:</strong> $${amount.toFixed(2)}</div>
                        <div class="tag-item"><strong>Date:</strong> ${formattedDate}</div>
                        <div class="tag-item"><strong>Purpose:</strong> ${purpose}</div>
                        <div class="tag-item"><strong>Category:</strong> ${category}</div>
                        <div class="tag-item"><strong>Transaction ID:</strong> ${transactionId}</div>
                        <button class="view-cents-button" data-donation-id="${donationId}" aria-label="See every cent of this donation">See Every Cent</button>
                  `;
                  
                  tag.innerHTML = tagContent;
                  
                  // Add click handler for the "See Every Cent" button
                  const viewCentsButton = tag.querySelector('.view-cents-button');
                  if (viewCentsButton) {
                        viewCentsButton.addEventListener('click', (e) => {
                              e.stopPropagation();
                              e.preventDefault();
                              const id = viewCentsButton.getAttribute('data-donation-id');
                              if (id && data) {
                                    // Clear active mobile tag when entering focus mode
                                    this.activeMobileTag = null;
                                    this.enterFocusMode(data, id);
                              }
                        });
                        // Also handle touch events for mobile
                        viewCentsButton.addEventListener('touchend', (e) => {
                              e.stopPropagation();
                              e.preventDefault();
                              const id = viewCentsButton.getAttribute('data-donation-id');
                              if (id && data) {
                                    this.activeMobileTag = null;
                                    this.enterFocusMode(data, id);
                              }
                        }, { passive: false });
                  }
                  
                  // Append to pool container so it's inside the box
                  this.pool.appendChild(tag);
                  
                  // Position tag relative to coin, inside the pool container
                  // Get position from Matter.js body if available, otherwise from style
                  let centX, centY;
                  if (cent.body) {
                        centX = cent.body.position.x;
                        centY = cent.body.position.y;
                  } else {
                        centX = parseFloat(cent.style.left) || 0;
                        centY = parseFloat(cent.style.top) || 0;
                  }
                  
                  const tagRect = tag.getBoundingClientRect();
                  
                  // Position to the right or left of the coin, near it
                  let tagX = centX + CONFIG.COIN_OFFSET_X; // Right side of coin
                  let tagY = centY - (tagRect.height / 2) + CONFIG.COIN_OFFSET_Y; // Vertically centered on coin
                  
                  // If tag would go outside pool bounds, position to the left instead
                  if (tagX + tagRect.width > this.poolWidth - 20) {
                        tagX = centX - tagRect.width - CONFIG.COIN_OFFSET_X;
                  }
                  
                  // Ensure tag stays within pool bounds
                  if (tagX < 10) tagX = 10;
                  if (tagX + tagRect.width > this.poolWidth - 10) {
                        tagX = this.poolWidth - tagRect.width - 10;
                  }
                  
                  if (tagY < 10) tagY = 10;
                  if (tagY + tagRect.height > this.poolHeight - 10) {
                        tagY = this.poolHeight - tagRect.height - 10;
                  }
                  
                  tag.style.position = 'absolute';
                  tag.style.left = tagX + 'px';
                  tag.style.top = tagY + 'px';
                  tag.style.zIndex = '1000';
                  
                  // Use requestAnimationFrame for smooth appearance
                  requestAnimationFrame(() => {
                        tag.classList.add('visible');
                  });
                  
                  // Keep tag visible when hovering over it
                  tag.addEventListener('mouseenter', () => {
                        // Cancel any pending hide
                        if (cent._hideTagTimeout) {
                              clearTimeout(cent._hideTagTimeout);
                              cent._hideTagTimeout = null;
                        }
                        tag.classList.add('visible');
                  });
                  
                  tag.addEventListener('mouseleave', () => {
                        // Start hide delay when leaving tag
                        this.scheduleHideTag(cent);
                  });
                  
                  this.activeTags.set(cent, tag);
            }

            handleCentTouchStart(event, cent) {
                  // If we are already dragging with Matter.js, do nothing
                  if (this.isDragging) return;
                  
                  // Stop Matter.js from immediately treating this as a drag
                  event.stopPropagation();
                  
                  // Record the starting time and position of the touch
                  const touch = event.touches[0];
                  if (touch) {
                        cent._touchStartTime = Date.now();
                        cent._touchStartX = touch.clientX;
                        cent._touchStartY = touch.clientY;
                        cent._touchTarget = event.target;
                        // Mark this as a potential tap. We'll verify this on touchend
                        cent._potentialTap = true;
                  }
            }

            handleCentTouchEnd(event, cent) {
                  // If this wasn't a potential tap (e.g., a drag already started), do nothing
                  if (!cent._potentialTap || !cent._touchStartTime) {
                        cent._touchStartTime = null;
                        cent._potentialTap = false;
                        return;
                  }
                  
                  const touch = event.changedTouches[0];
                  if (!touch) {
                        cent._touchStartTime = null;
                        cent._potentialTap = false;
                        return;
                  }
                  
                  // It's no longer a potential tap, we are now deciding what it was
                  cent._potentialTap = false;
                  
                  const touchDuration = Date.now() - cent._touchStartTime;
                  
                  // Check if the finger moved significantly
                  const deltaX = Math.abs(touch.clientX - (cent._touchStartX || touch.clientX));
                  const deltaY = Math.abs(touch.clientY - (cent._touchStartY || touch.clientY));
                  
                  // Clear touch data
                  cent._touchStartTime = null;
                  cent._touchStartX = null;
                  cent._touchStartY = null;
                  
                  // DEFINE A "TAP": A short touch that didn't move much
                  const isTap = touchDuration < 250 && deltaX < 10 && deltaY < 10;
                  
                  if (isTap) {
                        // It was a tap! Prevent any other action
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        
                        // Use requestAnimationFrame to ensure UI updates happen
                        requestAnimationFrame(() => {
                              // --- Mobile Toggle Logic ---
                              // If this cent's tag is already open, close it
                              if (this.activeMobileTag === cent) {
                                    this.hideTag(cent);
                                    this.activeMobileTag = null;
                              } else {
                                    // If another cent's tag is open, close that one first
                                    if (this.activeMobileTag) {
                                          this.hideTag(this.activeMobileTag);
                                    }
                                    // Now, show the new tag
                                    this.showTag(event, cent);
                                    this.activeMobileTag = cent; // Remember which tag is open
                              }
                        });
                  }
                  // If it wasn't a tap (it was a long press or a drag), do nothing and let Matter.js handle it
            }

            scheduleHideTag(cent) {
                  // Cancel any existing timeout
                  if (cent._hideTagTimeout) {
                        clearTimeout(cent._hideTagTimeout);
                  }
                  
                  // On mobile, don't auto-hide if this is the active mobile tag
                  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                  if (isTouchDevice && this.activeMobileTag === cent) {
                        return; // Don't auto-hide on mobile - user must tap elsewhere
                  }
                  
                  // Schedule hide with delay to allow moving mouse from cent to tag
                  cent._hideTagTimeout = setTimeout(() => {
                        this.hideTag(cent);
                        cent._hideTagTimeout = null;
                  }, 300); // 300ms delay - enough time to move mouse but not too long
            }

            hideTag(cent) {
                  // Clear any pending timeout
                  if (cent._hideTagTimeout) {
                        clearTimeout(cent._hideTagTimeout);
                        cent._hideTagTimeout = null;
                  }
                  
                  // Clear active mobile tag if this is it
                  if (this.activeMobileTag === cent) {
                        this.activeMobileTag = null;
                  }
                  
                  const tag = this.activeTags.get(cent);
                  if (tag) {
                        tag.classList.remove('visible');
                        setTimeout(() => {
                              if (tag.parentNode) {
                                    tag.parentNode.removeChild(tag);
                              }
                              // WeakMap automatically handles cleanup, but we can explicitly delete
                              this.activeTags.delete(cent);
                        }, 200);
                  }
            }

            updateStats() {
                  const totalDonationsEl = document.getElementById('totalDonations');
                  const totalAmountEl = document.getElementById('totalAmount');
                  const totalDonorsEl = document.getElementById('totalDonors');
                  
                  if (totalDonationsEl) {
                        this.animateValue(totalDonationsEl, this.stats.totalDonations, (val) => Math.floor(val).toLocaleString());
                  }
                  if (totalAmountEl) {
                        this.animateValue(totalAmountEl, this.stats.totalAmount, (val) => '$' + val.toFixed(2));
                  }
                  if (totalDonorsEl) {
                        this.animateValue(totalDonorsEl, this.stats.totalDonors, (val) => Math.floor(val).toLocaleString());
                  }
            }

            animateValue(element, target, formatter) {
                  const start = parseFloat(element.textContent.replace(/[^0-9.]/g, '')) || 0;
                  const duration = 1000;
                  const startTime = performance.now();
                  
                  const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const ease = 1 - Math.pow(1 - progress, 3);
                        const current = start + (target - start) * ease;
                        element.textContent = formatter(current);
                        
                        if (progress < 1) {
                              requestAnimationFrame(animate);
                        } else {
                              element.textContent = formatter(target);
                        }
                  };
                  
                  requestAnimationFrame(animate);
            }


            destroy() {
                  // Clear search debounce timer
                  if (this.searchDebounceTimer) {
                        clearTimeout(this.searchDebounceTimer);
                  }
                  
                  if (this.runner) {
                        Runner.stop(this.runner);
                  }
                  if (this.engine) {
                        Engine.clear(this.engine);
                  }
                  if (this.airtablePollInterval) {
                        clearInterval(this.airtablePollInterval);
                  }
                  
                  // Clean up all cents and their physics bodies
                  this.cents.forEach(cent => {
                        // Properly remove event listeners
                        this.returnCentToPool(cent);
                        if (cent.parentNode) {
                              cent.parentNode.removeChild(cent);
                        }
                  });
                  
                  this.cents = [];
                  this.visibleCents.clear();
                  // WeakMap doesn't need clearing, but we can clear if using Map
                  if (this.activeTags instanceof Map) {
                        this.activeTags.clear();
                  }
            }
      }

      // Initialize donation pool when DOM is ready
      let donationPool;
      function initDonationPool() {
            const poolContainer = document.getElementById('donationPool');
            if (poolContainer) {
                  donationPool = new DonationPool(poolContainer);
            } else {
                  // Retry if container not ready yet
                  setTimeout(initDonationPool, 100);
            }
      }
      
      if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initDonationPool);
      } else {
            initDonationPool();
      }

      // Stoplight menu functionality
      const stoplight = document.getElementById('stoplight');
      const dropdownMenu = document.getElementById('dropdown-menu');
      let isMenuOpen = false;

      function toggleMenu() {
        isMenuOpen = !isMenuOpen;
        stoplight.classList.toggle('active', isMenuOpen);
        dropdownMenu.classList.toggle('active', isMenuOpen);
        stoplight.setAttribute('aria-expanded', isMenuOpen ? 'true' : 'false');
      }

      // Add keyboard support for stoplight
      stoplight.setAttribute('role', 'button');
      stoplight.setAttribute('tabindex', '0');
      stoplight.setAttribute('aria-label', 'Open navigation menu');
      stoplight.setAttribute('aria-expanded', 'false');
      stoplight.setAttribute('aria-haspopup', 'true');

      stoplight.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleMenu();
      });

      stoplight.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown') {
          e.preventDefault();
          toggleMenu();
        }
      });

      document.addEventListener('click', (e) => {
        if (!stoplight.contains(e.target) && !dropdownMenu.contains(e.target) && isMenuOpen) {
          toggleMenu();
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isMenuOpen) {
          toggleMenu();
        }
      });

      dropdownMenu.addEventListener('click', (e) => {
        e.stopPropagation();
      });
      
      
      // Section animation on scroll
      const sections = document.querySelectorAll('.database-section');
      const observerOptions = {
            threshold: 0.1
      };
      
      const sectionObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach((entry, index) => {
                  if (entry.isIntersecting) {
                        setTimeout(() => {
                              entry.target.classList.add('visible');
                        }, index * 100);
                        observer.unobserve(entry.target);
                  }
            });
      }, observerOptions);
      
      sections.forEach(section => sectionObserver.observe(section));
  </script>
  
  <script>
    // --- NATIVE FONT LOADING ---
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => {
        document.body.classList.remove('fonts-loading');
        document.body.classList.add('fonts-loaded');
      });
      
      // Fallback timeout
      setTimeout(() => {
        document.body.classList.remove('fonts-loading');
        document.body.classList.add('fonts-loaded');
      }, 3000);
    } else {
      // Fallback for older browsers
      document.body.classList.remove('fonts-loading');
      document.body.classList.add('fonts-loaded');
    }
    // --- END FONT LOADING ---
  </script>
</body>
</html>
